<!-- Generated by agents-md: DO NOT EDIT DIRECTLY. Edit *.agents.md fragments instead. Higher priority fragments appear first and win conflicts. -->

<!-- source: .ai/rules/shared/rules/communication.mdc priority=0 -->
---
description: Communication style
globs:
alwaysApply: true
---
# Communication Style

- Be direct and actionable in suggestions
- Explain the "why" behind recommendations
- Act as a knowledgeable owner, not just an assistant
- Keep explanations concise but thorough
<!-- /source: .ai/rules/shared/rules/communication.mdc -->

<!-- source: .ai/rules/shared/rules/documentation-rules.mdc priority=0 -->
---
description: Documentation rules
globs: *.mission.md
alwaysApply: false
---
# Documentation Rules

- Update documentations before Git commit.
- Create diagrams with MermaidJS syntax.
<!-- /source: .ai/rules/shared/rules/documentation-rules.mdc -->

<!-- source: .ai/rules/shared/rules/js-rules.mdc priority=0 -->
---
description: JavaScript & TypeScript rules
globs:
alwaysApply: true
---
# JavaScript & TypeScript Rules

## Core

- Write typed, functional code without mutations or side effects when possible
- Prefer functions over classes; but avoid complex FP patterns like monads
- Create self-explanatory code with descriptive variable names (isLoading, hasError)
- Follow YAGNI (You Aren't Gonna Need It) to prevent speculatives
- Proactively address potential UX issues

## Functional Style

- Prefer `map`/`reduce` over loops
- Use ternary expressions over if/else when appropriate
- Use ts-pattern `match` over variable mutation
- Favor composition over duplication
- Avoid mutations and for loops

## Code Organization

- **Code Style**: Follow existing patterns in the codebase. Otherwise, as declarative as possible.
- **Documentation**: Update relevant documentation when making significant changes.
- **Security**: Never commit sensitive data or credentials
- **Files**: ~300 lines maximum
- **Action**: Proactively suggest refactoring when approaching these limits
- **Prefer native solutions** over third-party libraries when possible. Only suggest external dependencies if they provide significant value
- Place exported (public) functions and constants at the top of files
- Structure exported functions to orchestrate small, private helper functions:
  - Each private function handles one clear step
  - Exported functions represent the high-level flow
- Prefer named exports over default exports
- Import from source files directly (avoid index re-exports) for better tree-shakability
- Write comments only to explain logic, assumptions, edge cases, and trade-offs; never include progress/meta notes (e.g., "updated this", "now changed", "this is new code").

## Naming & Style

- Indent with 2 spaces
- Use single quotes
- Omit line-ending semicolons in JavaScript/TypeScript
- Declare functions with `function name()` instead of `const name = () =>`
- Add jsdoc header comments to big exported functions to explain what, how and why.

## TypeScript Specifics

- Use interfaces over types
- Use string unions instead of enums
- Type annotations: prefer `Array<T>` over `T[]`

## Avoiding Indirections

- "Rule of Three" - only abstract after seeing at least three concrete implementations
- Consolidate related functionality into cohesive modules
- Use composition over inheritance
- Eliminate abstractions that don't provide clear benefits
- Ensure newcomers can understand the system without learning numerous abstraction concepts
<!-- /source: .ai/rules/shared/rules/js-rules.mdc -->

<!-- source: .ai/rules/shared/rules/mission-rules.mdc priority=0 -->
---
description: Basic guidline for all AI missions
globs: *.mission.md
alwaysApply: false
---
# AI Mission Guidelines

## Overview

AI Mission is a core component in this agentic workflow framework, analogous to sprints in Agile methodologies but without size constraints. Each mission focuses on a single work unit, allowing for horizontal slicing of complex tasks.

## Mission Structure

- Mission files use the `.mission.md` extension
- Each mission should focus on a single element or functional unit
- Missions are horizontally sliced for focus. Ignore time/effort estimates and constraints.
- Each mission contains multiple tasks, with each task representing one story point

### Example Mission Slicing

1-jbhifi-search-planning
2-jbhifi-search-fetch-search-hits
3-jbhifi-search-transform-to-items
4-jbhifi-search-scoring
5-jbhifi-search-save-to-db

### Task Format

Tasks are recorded and updated in mission file.

Example:

```md
## Tasks

- [x] Task 1: [title] 
  - Description: [description]
  - Log: [to-be-summarised]
- [ ] Task 2: [title]
  - Description: [description]
  - Acceptance Criteria: [acceptance criteria]
  - Outcome: [outcome]
  - Log: [to-be-summarised]
```

## AI Agent Responsibilities

### Task Management

- Tasks should be executed one by one
- Add, update, reorder, and cancel tasks as needed
- Mark cancelled tasks as complete with `[cancelled]` tag and explain the reason
- Prioritize tasks based on dependencies, importance, and complexity. Low-hanging fruits first.
- Keep tasks small, focused, and achievable in a single sitting
- Write tasks with clear, concise language and specific outcomes
- Include acceptance criteria when needed
- User may manually add tasks with the `[new]` tag
- AI agent may ask questions and raise challenge when pick up the `[new]` tasks
  
#### Task Completion

After working on each task, AI agent should:

1. Update mission file, tick task checkbox, i.e. change from `- [ ]` to `- [x]` to mark completion
2. Update the completed task's log
3. Update documentations in `/notes/` and maybe `/wiki/docs` but only when necessary according to Documentation Rules.

### Log

- Maintain a summarized log for each task including:
  - Work completed
  - Significant insights (assumptions, challenges, decisions, rationales, solutions, compromises, tech debt)
  - Only log key insights when significant, not when workflows are smooth or obvious

### Execution

- Execute all tasks until completion except when need to pause for user input like the first three tasks.
- When blocked:
  - Log the blocker/challenge, attempts, and rationales
  - Suggest potential workarounds and alternative approaches
  - Ask the user for help, offering options to:
    - Manually fix the blocker
    - Approve the workaround
    - Pivot to a different approach
    - Skip to the next task

### Mission Completion

When all tasks are completed and the user requests to "Conclude a mission", add a "Mission Review and Retrospective" section above the "Tasks" section that:

1. Summarizes work done, compromises, lessons learned, challenges, solutions, and tech debt
2. Suggests ideas for the next mission
3. Lists both workflow and implementation retrospective points (good, bad, questions, improvement ideas)

## Kickoff

- Always start a mission with the kickoff steps. 
- Create Kickoff files at `[path-of-current-mission]/kickoffs/<mission-number>-<mission-name>.kickoff.md`.
- Pause and ask for user feedback in each kickoff step. 
- DO NOT jump to the next kickoff step until user provided feedback and prompt to continue. 
- Like tasks, tick checkbox to mark kickoff step complete after each step.

Kickoff steps:

- [ ] Step 1: "Clarify the Mission Goal"
   1. List questions in the Kickoff file to clarify the mission (context, scope, constraints, priorities)
   2. Pause and ask user to answer the questions
   3. User will provide feedback and then prompt to continue. 
   4. Update mission goal in mission file based on feedback

- [ ] Step 2: "Are we doing the right thing?"
   1. Consider blind spots in business and technical aspects. Challenge the mission goal. List them in the Kickoff file.
   2. Pause and ask user to confirm and provide feedback
   3. User will provide feedback and then prompt to continue. 
   4. Update mission goal in mission file based on feedback

- [ ] Step 3: "List and rank solution options"
   1. List and rank potential solutions in Kickoff file
   2. Pause and ask user to select an option
   3. User will provide feedback and then prompt to continue. 
   4. Update mission goal in mission file
   4. Draft tasks based on feedback

- [ ] Step 4: "Specification"
   1. List behaviour specifications of happy path, unhappy path, edge cases in Kickoff file
   2. Pause and ask user to confirm and provide feedback
   3. User will provide feedback and then prompt to continue. 
   4. Update mission goal in mission file
   5. Update tasks based on feedback

## Version Control

- start the mission with checking and setting git branch to: `mission-<mission-number>-<mission-name>`
<!-- /source: .ai/rules/shared/rules/mission-rules.mdc -->

<!-- source: .ai/rules/shared/rules/principles.mdc priority=0 -->
---
description: Core principles
globs:
alwaysApply: true
---
# Principles

Value end-user UX over everything including tech difficulty, complexity, and performance.

1. **UX obsessed**
   - Minimum friction: least clicks required on common operations
   - Maximum magic:
     - Smart pro-active UX design. Provide before user starts thinking. E.g. prefill dropdown if there is only one option.
     - Battery included - default best config. Optimal defaults out-of-the-box, minimal user configuration required.
   - Reactive UXUI: implement real-time feeling UI. Patterns include but not limited to
     - optimistic updates
     - invalidating all queries after user updates
     - WebSocket push to client after system updates

2. Tech wise:
   - **Think Small**: Ignore performance, cost, and scalability. Day-0 mindset with extreme simplicity. However, security is still important.
   - **Idempotency**: All operations safe to retry with proper deduplication.
   - **Auth**: Every non-public endpoint/operation must pass through authn and authz.
   - At planning, always start with thinking reusing and building reusable modules to improve system consitencies.
<!-- /source: .ai/rules/shared/rules/principles.mdc -->

<!-- source: .ai/rules/shared/rules/shadcn.mdc priority=0 -->
---
description: shadcn/ui
globs:
alwaysApply: true
---

# shadcn/ui rules

- Apply shadcn components wherever applicable; do not handcraft equivalents!
- As shadcn get super frequent updates, for any shadcn-related planning or anytime in doubt, use the shadcn MCP tools.
- At planning, always start with thinking reusing and building reusable modules to improve UI consitencies.

## Implementation

- First call the shadcn mcp tool to see correct usage.
- Install components via MCP; do not write files manually.
- Then implement using the demonstrated pattern.

## shadcn.io complex Components

- Kanban board: https://www.shadcn.io/components/data/kanban.mdx
- AI Chat: https://www.shadcn.io/ai
- Data List: https://www.shadcn.io/components/data/list
- Data Table: https://www.shadcn.io/components/data/table
- Menu Dock: https://www.shadcn.io/components/dock/menu-dock
- Message Dock: https://www.shadcn.io/components/dock/message-dock
- Combobox: https://www.shadcn.io/components/forms/combobox
- Editor: https://www.shadcn.io/components/forms/editor
- Minimal Tiptap: https://www.shadcn.io/components/forms/minimal-tiptap
- Status: https://www.shadcn.io/components/visualization/status
<!-- /source: .ai/rules/shared/rules/shadcn.mdc -->
