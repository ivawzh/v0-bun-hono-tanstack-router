# Solo Unicorn API and MCP Design

## Overview

This document defines how Solo Unicorn exposes its functionality through a unified MCP-first interface, with oRPC OpenAPI API endpoints wrappers where needed. The CLI and workstation agents primarily communicate via MCP tools over WebSocket. The web app and third parties can use REST endpoints that internally delegate to MCP tools.

Principles:
- Single source of truth for domain operations: MCP tools
- MCP tools are thin adapters around API endpoints, where applicable
- Authn via Monster Auth tokens; Authz in app layer (TypeScript)

## Authentication

- Bearer tokens issued by Monster Auth (email is canonical identity)
- Workspace/workstation-scoped tokens where appropriate
- All MCP tool invocations include auth context (userId, organizationId)

## Namespacing & Tenancy

- Tools are namespaced by domain: mission., project., repository.
- All calls must include projectId or organizationId where relevant

## Error Model

- MCP: { error: { code: string, message: string, details?: any } }
- REST: HTTP status + { error: { code, message, details? } }

## Mission Tools as API wrappers

- tools discovery is auto-generated by @modelcontextprotocol/sdk
- (Not in MVP) mission.v1.create({ projectId, title, description, spec?, repositoryId, additionalRepositoryIds?, actorId?, flowId?, prMode?, prNumber? }) -> { missionId }. Through POST /api/v1/missions.
- mission.v1.update({ missionId, spec?, solution?, spec?, priority?, list?, stage?, flowId?, tasks?: Task[]; currentTask?: number, activeWorkstationId? }). Through PATCH /api/v1/missions/{id}.
- mission.v1.get({ missionId }) -> Mission.v1. Through GET /api/v1/missions/{id}.
- mission.v1.list({ projectId, filter? }) -> Mission[]. Through GET /api/v1/projects/{projectId}/missions.
- (Not in MVP) mission.v1.reject({ missionId, feedback: string }). Through POST /api/v1/missions/{id}/reject.

Types:
- Task: { title: string; }
- Mission minimal: { id, projectId, title, description, spec?, solution?, tasks?: Task[], currentTask?: number, repositoryId, additionalRepositoryIds?: number[], prMode, list, stage, priority }

## Repository Tools as API wrappers

- (Not in MVP) repository.linkGithub({ projectId, githubUrl }) -> { repositoryId } // repositoryId is GitHub numeric repo id
- (Not in MVP) repository.list({ projectId }) -> Repository[]

Note: Public discovery endpoints remain as designed in feature-requirements; they do not require MCP unless authenticated operations are performed.

## Transport

- MCP over HTTPS (Solo Unicorn API non-streaming)
- REST over HTTPS

## Security

- Authz in app layer (TypeScript). Do not rely on SQL functions for permission checks
- All MCP tools enforce project/org ownership and permissions
- Rate limiting on REST via middleware; MCP via gateway quotas

## Repository Identification

- repositoryId is GitHub numeric repository ID (BIGINT). For non-GitHub providers (future), use provider+id composite encoded as string (e.g., "github:123456789"). MVP supports GitHub only.

## Versioning

- MCP tools are versioned via namespace suffix if breaking changes are required (e.g., mission.v2.create)
- API endpoints use URL versioning (/api/v1)

## Open Questions (Post-MVP)

- Streaming
- Task append/remove/reorder
- Partial document streaming for large specs
- Bidirectional prompt negotiation for dynamic prompts
